#include "toyrenderer_common.hlsli"
#include "ShaderInterop.h"

// NOTE: ghetto function generated by AI
// Returns 1.0 if the pixel at UV is part of the digit, 0.0 otherwise (with anti-aliasing)
float DrawDigit(float2 uv, int digit)
{
    float2 p = uv; // UV in [0,1]x[0,1], with (0,0) at top-left, (1,1) at bottom-right
    // Flip y-coordinate to match original logic (convert to bottom-left origin)
    p.y = 1.0 - p.y;
    
    float thickness = 0.1; // Stroke thickness
    float halfThickness = thickness * 0.5;
    float aa = 0.01; // Anti-aliasing softness
    float aspect = 1.0; // Adjust if UV block is not square
    p.x *= aspect;

    float dist = 1000.0; // Large initial distance for SDF-like approach

    // Define segments for each digit
    if (digit == 0)
    {
        // "0": Oval shape (top/bottom bars + left/right verticals)
        bool topBar = (p.y > 0.85 && p.y < 0.95) && (p.x > 0.2 && p.x < 0.8);
        bool bottomBar = (p.y > 0.05 && p.y < 0.15) && (p.x > 0.2 && p.x < 0.8);
        bool leftBar = (p.x > 0.2 && p.x < 0.3) && (p.y > 0.05 && p.y < 0.95);
        bool rightBar = (p.x > 0.7 && p.x < 0.8) && (p.y > 0.05 && p.y < 0.95);
        if (topBar || bottomBar || leftBar || rightBar)
            dist = 0.0;
        else
            dist = min(
                min(abs(p.y - 0.9) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                    abs(p.y - 0.1) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0)),
                min(abs(p.x - 0.25) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0),
                    abs(p.x - 0.75) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0))
            );
    }
    else if (digit == 1)
    {
        // "1": Vertical line
        bool vertical = (p.x > 0.45 && p.x < 0.55) && (p.y > 0.05 && p.y < 0.95);
        if (vertical)
            dist = 0.0;
        else
            dist = abs(p.x - 0.5) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0);
    }
    else if (digit == 2)
    {
        // "2": Top bar, right vertical, middle bar, left diagonal, bottom bar
        bool topBar = (p.y > 0.85 && p.y < 0.95) && (p.x > 0.2 && p.x < 0.8);
        bool rightBar = (p.x > 0.7 && p.x < 0.8) && (p.y > 0.45 && p.y < 0.85);
        bool middleBar = (p.y > 0.45 && p.y < 0.55) && (p.x > 0.2 && p.x < 0.8);
        bool bottomBar = (p.y > 0.05 && p.y < 0.15) && (p.x > 0.2 && p.x < 0.8);
        bool diagonal = abs(p.x + p.y - 1.0) < thickness && (p.x > 0.2 && p.x < 0.7) && (p.y > 0.15 && p.y < 0.45);
        if (topBar || rightBar || middleBar || bottomBar || diagonal)
            dist = 0.0;
        else
            dist = min(
                min(
                    min(abs(p.y - 0.9) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.x - 0.75) * (p.y > 0.45 && p.y < 0.85 ? 1.0 : 1000.0)),
                    min(abs(p.y - 0.5) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.y - 0.1) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0))
                ),
                abs(p.x + p.y - 1.0) * (p.x > 0.2 && p.x < 0.7 && p.y > 0.15 && p.y < 0.45 ? 1.0 : 1000.0)
            );
    }
    else if (digit == 3)
    {
        // "3": Top/middle/bottom bars + right vertical
        bool topBar = (p.y > 0.85 && p.y < 0.95) && (p.x > 0.2 && p.x < 0.8);
        bool middleBar = (p.y > 0.45 && p.y < 0.55) && (p.x > 0.2 && p.x < 0.8);
        bool bottomBar = (p.y > 0.05 && p.y < 0.15) && (p.x > 0.2 && p.x < 0.8);
        bool rightBar = (p.x > 0.7 && p.x < 0.8) && (p.y > 0.05 && p.y < 0.95);
        if (topBar || middleBar || bottomBar || rightBar)
            dist = 0.0;
        else
            dist = min(
                min(
                    min(abs(p.y - 0.9) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.y - 0.5) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0)),
                    abs(p.y - 0.1) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0)
                ),
                abs(p.x - 0.75) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0)
            );
    }
    else if (digit == 4)
    {
        // "4": Left vertical, middle bar, right vertical
        bool leftBar = (p.x > 0.2 && p.x < 0.3) && (p.y > 0.45 && p.y < 0.95);
        bool middleBar = (p.y > 0.45 && p.y < 0.55) && (p.x > 0.2 && p.x < 0.8);
        bool rightBar = (p.x > 0.7 && p.x < 0.8) && (p.y > 0.05 && p.y < 0.95);
        if (leftBar || middleBar || rightBar)
            dist = 0.0;
        else
            dist = min(
                min(abs(p.x - 0.25) * (p.y > 0.45 && p.y < 0.95 ? 1.0 : 1000.0),
                    abs(p.y - 0.5) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0)),
                abs(p.x - 0.75) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0)
            );
    }
    else if (digit == 5)
    {
        // "5": Top bar, left vertical, middle bar, right bottom curve
        bool topBar = (p.y > 0.85 && p.y < 0.95) && (p.x > 0.2 && p.x < 0.8);
        bool leftBar = (p.x > 0.2 && p.x < 0.3) && (p.y > 0.45 && p.y < 0.95);
        bool middleBar = (p.y > 0.45 && p.y < 0.55) && (p.x > 0.2 && p.x < 0.8);
        bool bottomBar = (p.y > 0.05 && p.y < 0.15) && (p.x > 0.2 && p.x < 0.8);
        bool rightBar = (p.x > 0.7 && p.x < 0.8) && (p.y > 0.05 && p.y < 0.45);
        if (topBar || leftBar || middleBar || bottomBar || rightBar)
            dist = 0.0;
        else
            dist = min(
                min(
                    min(abs(p.y - 0.9) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.x - 0.25) * (p.y > 0.45 && p.y < 0.95 ? 1.0 : 1000.0)),
                    min(abs(p.y - 0.5) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.y - 0.1) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0))
                ),
                abs(p.x - 0.75) * (p.y > 0.05 && p.y < 0.45 ? 1.0 : 1000.0)
            );
    }
    else if (digit == 6)
    {
        // "6": Top bar, left vertical, middle bar, bottom bar, right bottom curve
        bool topBar = (p.y > 0.85 && p.y < 0.95) && (p.x > 0.2 && p.x < 0.8);
        bool leftBar = (p.x > 0.2 && p.x < 0.3) && (p.y > 0.05 && p.y < 0.95);
        bool middleBar = (p.y > 0.45 && p.y < 0.55) && (p.x > 0.2 && p.x < 0.8);
        bool bottomBar = (p.y > 0.05 && p.y < 0.15) && (p.x > 0.2 && p.x < 0.8);
        bool rightBar = (p.x > 0.7 && p.x < 0.8) && (p.y > 0.05 && p.y < 0.45);
        if (topBar || leftBar || middleBar || bottomBar || rightBar)
            dist = 0.0;
        else
            dist = min(
                min(
                    min(abs(p.y - 0.9) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.x - 0.25) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0)),
                    min(abs(p.y - 0.5) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.y - 0.1) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0))
                ),
                abs(p.x - 0.75) * (p.y > 0.05 && p.y < 0.45 ? 1.0 : 1000.0)
            );
    }
    else if (digit == 7)
    {
        // "7": Top bar, right diagonal
        bool topBar = (p.y > 0.85 && p.y < 0.95) && (p.x > 0.2 && p.x < 0.8);
        bool diagonal = abs(p.x + p.y - 1.3) < thickness && (p.x > 0.2 && p.x < 0.8) && (p.y > 0.05 && p.y < 0.85);
        if (topBar || diagonal)
            dist = 0.0;
        else
            dist = min(
                abs(p.y - 0.9) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                abs(p.x + p.y - 1.3) * (p.x > 0.2 && p.x < 0.8 && p.y > 0.05 && p.y < 0.85 ? 1.0 : 1000.0)
            );
    }
    else if (digit == 8)
    {
        // "8": Top/bottom bars, left/right verticals, middle bar
        bool topBar = (p.y > 0.85 && p.y < 0.95) && (p.x > 0.2 && p.x < 0.8);
        bool bottomBar = (p.y > 0.05 && p.y < 0.15) && (p.x > 0.2 && p.x < 0.8);
        bool leftBar = (p.x > 0.2 && p.x < 0.3) && (p.y > 0.05 && p.y < 0.95);
        bool rightBar = (p.x > 0.7 && p.x < 0.8) && (p.y > 0.05 && p.y < 0.95);
        bool middleBar = (p.y > 0.45 && p.y < 0.55) && (p.x > 0.2 && p.x < 0.8);
        if (topBar || bottomBar || leftBar || rightBar || middleBar)
            dist = 0.0;
        else
            dist = min(
                min(
                    min(abs(p.y - 0.9) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.y - 0.1) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0)),
                    min(abs(p.x - 0.25) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0),
                        abs(p.x - 0.75) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0))
                ),
                abs(p.y - 0.5) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0)
            );
    }
    else if (digit == 9)
    {
        // "9": Top bar, left vertical, middle bar, right vertical
        bool topBar = (p.y > 0.85 && p.y < 0.95) && (p.x > 0.2 && p.x < 0.8);
        bool leftBar = (p.x > 0.2 && p.x < 0.3) && (p.y > 0.45 && p.y < 0.95);
        bool middleBar = (p.y > 0.45 && p.y < 0.55) && (p.x > 0.2 && p.x < 0.8);
        bool rightBar = (p.x > 0.7 && p.x < 0.8) && (p.y > 0.05 && p.y < 0.95);
        bool bottomBar = (p.y > 0.05 && p.y < 0.15) && (p.x > 0.2 && p.x < 0.8);
        if (topBar || leftBar || middleBar || rightBar || bottomBar)
            dist = 0.0;
        else
            dist = min(
                min(
                    min(abs(p.y - 0.9) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.x - 0.25) * (p.y > 0.45 && p.y < 0.95 ? 1.0 : 1000.0)),
                    min(abs(p.y - 0.5) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0),
                        abs(p.x - 0.75) * (p.y > 0.05 && p.y < 0.95 ? 1.0 : 1000.0))
                ),
                abs(p.y - 0.1) * (p.x > 0.2 && p.x < 0.8 ? 1.0 : 1000.0)
            );
    }

    // Apply anti-aliasing
    return smoothstep(halfThickness + aa, halfThickness - aa, dist);
}

cbuffer g_VisualizeMinMipParametersBuffer : register(b0) { VisualizeMinMipParameters g_VisualizeMinMipParameters; }
Texture2D g_Input : register(t0);
sampler g_LinearClampSampler : register(s0);

void PS_VisualizeMinMip(
    in float4 inPosition : SV_POSITION,
    in float2 inUV : TEXCOORD0,
    out float4 outColor : SV_Target
)
{
    float minMipData = g_Input.Sample(g_LinearClampSampler, inUV).r;
    uint mip = min(7, (uint)(minMipData));
    float2 tileUV = frac(inUV * g_VisualizeMinMipParameters.m_TextureDimensions);

    if (g_VisualizeMinMipParameters.m_bVisualizeWithColor)
    {
        static const float3 kMipColors[8] =
        {
            { 1.0f, 0.0f, 0.0f }, // Mip 0 - Red
            { 1.0f, 0.5f, 0.0f }, // Mip 1 - Orange
            { 1.0f, 1.0f, 0.0f }, // Mip 2 - Yellow
            { 0.5f, 1.0f, 0.0f }, // Mip 3 - Light Green
            { 0.0f, 1.0f, 0.0f }, // Mip 4 - Green
            { 0.0f, 0.5f, 1.0f }, // Mip 5 - Light Blue
            { 0.0f, 0.0f, 1.0f }, // Mip 6 - Blue
            { 0.5f, 0.0f, 1.0f }  // Mip 7 - Purple
        };
        outColor = float4(kMipColors[mip], 1.0f);

        if (tileUV.x > 0.9 || tileUV.x < 0.1 || tileUV.y > 0.9 || tileUV.y < 0.1)
        {
            outColor = float4(0.0f, 0.0f, 0.0f, 1.0f);
        }
    }
    else
    {
        float SDF = DrawDigit(tileUV, mip);
        outColor.rgb = SDF.xxx;
        outColor.a = 1.0f;
    }
}
